---
title: "MADRaT Exercise"
author: "David Chen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MADRat exercise}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

In this exercise, we will practice reading in and transforming input data through MADRaT. We will create our own MADRat-based package for data input processing. For this example, we will use World Bank World Development Indicator (WDI) data, with the WDI library for easy direct download.

## New "mymadrat" Package
First, create a new package through the "New Project-> New Directory-> R Package" option in RStudio and call it "mymadrat". Add the following script saved as madrat.R to the newly created R folder. 

```{r, echo = TRUE, eval=FALSE}
### madrat.R
#' @importFrom madrat vcat
> .onLoad <- function(libname, pkgname){
> madrat::setConfig(packages=c(madrat::getConfig("packages"),pkgname),
		  .cfgchecks=FALSE, .verbose=FALSE)
> }
#create an own warning function which redirects calls to vcat (package internal)
> warning <- function(...) vcat(0,...)
# create a own stop function which redirects calls to stop (package internal)
> stop <- function(...) vcat(-1,...)
# create an own cat function which redirects calls to cat (package internal)
> cat <- function(...) vcat(1,...)


```


## MADRaT Functions - Exercise

We will create new download, read, and convert functions for WDI indicators Population, GDP, Employment rate, Employment share in Agriculture, and Agricultural GDP. Each indicator should be a separate parameter within each function.
Note that each function needs to be named as a file and as a function with the wrapper, for example, readWDI.R

Remember that complete magclass objects are an array with the the regional (ISO3) dimension in the first dimension, the temporal dimension in the second, and data values in the third dimemsion(s) (3.1, 3.2...). 

### Download function

Note that if direct download not possible, data files can be manually created in the inputdata/sources folder. In that case, a download function is not necessary, but naming of the source folder must match the read functions.

```{r, echo = TRUE, eval=FALSE}
install.packages("WDI")
library(WDI)

downloadWDI <- function(...){

# Use the WDI() function to easily direct download WDI data;
  #with 1960 as the start year and 2018 as end; see ?WDI() for more help
install.packages("WDI")
library(WDI)

# Download these indicators, by creating a vector of indicators to put into WDI():
# "NY.GDP.MKTP.KD" National GDP in 2010 USD
# "SP.POP.TOTL" Total population
# "SL.EMP.TOTL.SP.ZS" Employment ratio
# "SL.AGR.EMPL.ZS" Employment in agriculture as % of total employment
# "NV.AGR.TOTL.KD" Agricultural GDP in 2010 USD

#Save the downloaded data as a .Rda file as the last step of the function
save()
}

```

### Read function

Read functions are the first step in transforming input data into magclass objects. They should be as simple as possible, with most steps of filling in, transforming, and data cleaning reserved for the convert function. The Read function should be able to specify between indicators (subtypes).

```{r, echo = TRUE, eval=FALSE}

readWDI <- function(...){

#begin by loading the dataset saved by the previous download function.
#Note that only the file name and extension are required, as madrat is configured to search for matching sources in its sources folder.
load(...)
  
#Use as.magpie() to transform the dataset into a magclass object. 
#Remember that magclass objects always have the spatial indicator (iso code, not country name) in their 1st dimension & the temporal dimension in 2nd dimenson.
#It is ideal to reshape the data into 'tidy' format, with only the last column containing data as.magpie(...tidy=TRUE). 
#In this case, we will use the melt() function. 

library(reshape2)
wdi <- melt(wdi, id.vars=c("iso2c", "year"))

#Now create the magpie object, fill in the missing parameters for as.magpie:
#Note the replacement parameter, which maintains the naming of the indicators


wdi <- as.magpie(wdi,..., replacement=".")

#Once the magclass object is created, we can specify the subtype/indicator desired,
#so that the read function only returns one indicator at a time.
#Use [] to subset the subtype:

x <- wdi[]

return(x)
}
```

### Convert Function

The convert function will complete the magclass object: All 249 countries represented in MAGPie need to have a value and be in ISO3 country code.

```{r, echo = TRUE, eval=FALSE}

convertWDI <- function(...){

  #Units need to be regularized in this function as well, for instance, MAgPIE uses population and GDP in millions:
  if (subtype %in% "NY.GDP.MKTP.KD", "SP.POP.TOTL","NV.AGR.TOTL.KD" ) {
    x <- x/1e6
}

# For these datasets, we need to convert the iso2c countrycodes into iso3c (this is also often done in the read function..)
# We can use the function countrycode(), with the magclass call getRegions. 

# Note:
# Other datasets may require other mapping conversions, there exist magclass specific tools: 
# toolCountry2isocode() and toolCell2isoCell() for instance
  
library(countrycode)
getRegions(x)<-countrycode(getRegions(x),"iso2c","iso3c")


# Note that some regions have now been turned into NA; you can check with getRegions()
# It would be important to be certain that no information is lost. In this case the NA's are mostly WB aggregate regions. 

x<-x[!is.na(getCells(x)),,] #remove NA regions


#clean_magpie() cleans MAgPIE objects so that they follow some extended magpie object rules (currently it makes sure that the dimnames have names and removes cell numbers if it is purely regional data)

x <- clean_magpie(x)


#Now fill the missing countries using toolCountryFill(), choose an arbitrary (Not NA!) fill value for now.

x <- toolCountryFill()

#Now we have a complete MAgPIE object! congratulations. 

return(x)}
  

```

### calcOutput

Magclass objects lend themselves easily to calculations between them. Use the read functions we just wrote to calculate agricultural GDP as a percentage of total gdp, using a new calcOutput function.

```{r, echo = TRUE, eval=FALSE}
calcAgGDP <- function(){

readSource("WDI", subtype="NY.GDP.MKTP.KD")

#note that by default, readSource also converts; otherwise set convert=FALSE
  
}

```
After the function is written and built, call calc functions through the calcOutput("type") wrapper. Try it now with the calcAgGDP function.

## Validation

MADRaT treats post-model run validation separately from the input data, though these often come from the same source. All validation functions are named using the "calcValid" output, and combine to create a .pdf validation document that compares model indicators with available validation data. Indicator names of calcValid outputs must match model indicators.
The "fullVALIDATION" function combines all calcValid functions and produces a .mif file, comparing validation data with model runs.
Take a look at the calcValidAgGDP in the package, along with "fullVALIDATION"

